# ==============================================================================
# MFE Promotion Pipeline - Deploy from GHCR to AWS
# ==============================================================================
# Runs in: btg-devops repository
# Triggered by: repository_dispatch from app repos OR manual workflow_dispatch
# Purpose: Pull artifact from GHCR â†’ Deploy to S3 â†’ Invalidate CloudFront
#
# ------------------------------------------------------------------------------
# âš™ï¸ SETUP INSTRUCTIONS
# ------------------------------------------------------------------------------
# 1. Create Environments in GitHub Settings (btg-devops repo):
#    - dev
#    - staging
#    - prod
#
# 2. Add Secrets to EACH Environment:
#    - AWS_ROLE_ARN: .............. IAM Role ARN for GitHub Actions OIDC (from terraform output)
#    - AWS_REGION: ................ Target AWS Region (e.g., us-east-1)
#    - S3_BUCKET_NAME: ............ S3 bucket name (e.g., btg-dev-mfe-assets) (from terraform output)
#    - CLOUDFRONT_DISTRIBUTION_ID:  CloudFront distribution ID (from terraform output)
#    - CLOUDFRONT_URL: ............ CloudFront URL (from terraform output, e.g., https://d123.cloudfront.net)
# ==============================================================================

name: MFE Promotion Pipeline

on:
  repository_dispatch:
    types: [deploy-mfe]
  workflow_dispatch:
    inputs:
      app_name:
        description: 'Application to deploy'
        required: true
        type: choice
        options:
          - shell
          - enhancer
      build_version:
        description: 'Build version (e.g., abc1234-20260113-143020)'
        required: true
        type: string
      environment:
        description: 'Target environment'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod

permissions:
  id-token: write
  contents: read
  packages: read

env:
  REGISTRY: ghcr.io

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event_name == 'repository_dispatch' && github.event.client_payload.environment || inputs.environment }}
    
    steps:
      # ========================================================================
      # Setup
      # ========================================================================
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set variables
        id: vars
        run: |
          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            APP_NAME="${{ github.event.client_payload.app_name }}"
            BUILD_VERSION="${{ github.event.client_payload.build_version }}"
            ENVIRONMENT="${{ github.event.client_payload.environment }}"
            SOURCE="${{ github.event.client_payload.source_repo }}"
          else
            APP_NAME="${{ inputs.app_name }}"
            BUILD_VERSION="${{ inputs.build_version }}"
            ENVIRONMENT="${{ inputs.environment }}"
            SOURCE="manual-trigger"
          fi
          
          echo "app_name=${APP_NAME}" >> $GITHUB_OUTPUT
          echo "build_version=${BUILD_VERSION}" >> $GITHUB_OUTPUT
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "source=${SOURCE}" >> $GITHUB_OUTPUT
          
          echo "ðŸ“‹ Deployment Info:"
          echo "  App: ${APP_NAME}"
          echo "  Version: ${BUILD_VERSION}"
          echo "  Environment: ${ENVIRONMENT}"
          echo "  Source: ${SOURCE}"
      
      # ========================================================================
      # Pull Artifact from GHCR
      # ========================================================================
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Pull artifact
        id: pull
        env:
          APP_NAME: ${{ steps.vars.outputs.app_name }}
          BUILD_VERSION: ${{ steps.vars.outputs.build_version }}
        run: |
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_NAME="${{ env.REGISTRY }}/${OWNER}/btg-${APP_NAME}-mfe:${BUILD_VERSION}"
          echo "ðŸ“¥ Pulling: ${IMAGE_NAME}"
          
          if ! docker pull ${IMAGE_NAME}; then
            echo "âŒ Failed to pull artifact from GHCR"
            exit 1
          fi
          
          # Extract artifact
          CONTAINER_ID=$(docker create ${IMAGE_NAME})
          docker cp ${CONTAINER_ID}:/artifact.tar.gz ./artifact.tar.gz || exit 1
          docker cp ${CONTAINER_ID}:/metadata.json ./metadata.json || exit 1
          docker rm ${CONTAINER_ID}
          
          # Extract files
          mkdir -p deploy
          tar -xzf artifact.tar.gz -C deploy/ || exit 1
          
          # ====================================================================
          # Restructure Artifact (If needed)
          # ====================================================================
          # Shell MFE -> Deploys to root (standard)
          # Other MFEs (Enhancer, etc.) -> Must go to /mfe-bundles/{appName}/
          # Assets -> Always stay in /assets/ (merged)
          
          if [[ "${APP_NAME}" != "shell" ]]; then
             echo "ðŸ“¦ Restructuring for ${APP_NAME}..."
             TARGET_DIR="deploy/mfe-bundles/${APP_NAME}"
             mkdir -p "${TARGET_DIR}"
  
             # Move Bundles (JS, CSS, JSON, Maps) from ROOT to TARGET_DIR
             # Logic: Move everything except 'assets' folder and nested dirs
             find deploy -maxdepth 1 -type f -exec mv {} "${TARGET_DIR}/" \;
             
             # Assets are assumed to be correctly namespaced in source (src/assets/enhancer)
             # So deploy/assets/enhancer should already exist if built correctly.
             # No action needed for assets if they are already in 'assets' folder at root.
             
             echo "âœ… Restructured files into ${TARGET_DIR}"
             ls -R deploy/
          fi
          
          echo "âœ… Artifact extracted"
          cat metadata.json
      
      # ========================================================================
      # Deploy to AWS
      # ========================================================================
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      - name: Deploy runtime config (Shell MFE only)
        if: steps.vars.outputs.app_name == 'shell'
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          ENV_NAME: ${{ steps.vars.outputs.environment }}
        run: |
          echo "ðŸ“ Deploying runtime config.json for shell-mfe"
          
          # Copy config from services/shell-mfe/config/{env}.json to S3 config/ folder
          CONFIG_FILE="services/shell-mfe/config/${ENV_NAME}.json"
          
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "âŒ Config file not found: $CONFIG_FILE"
            exit 1
          fi
          
          # Deploy to config/config.json path (matching public/config/config.json structure)
          aws s3 cp "$CONFIG_FILE" "s3://${S3_BUCKET}/config/config.json" \
            --cache-control "no-cache,no-store,must-revalidate" \
            --content-type "application/json"
          
          echo "âœ… Runtime config deployed to /config/config.json"
      
      - name: Deploy to S3
        env:
          S3_BUCKET: ${{ secrets.S3_BUCKET_NAME }}
          APP_NAME: ${{ steps.vars.outputs.app_name }}
        run: |
          echo "â˜ï¸ Deploying to S3: ${S3_BUCKET}"
          
          # ====================================================================
          # SAFE DEPLOYMENT STRATEGY (Shared Bucket)
          # ====================================================================
          
          # 1. Handle mfe-bundles (Strict Ownership - Sync with Delete)
          if [ -d "deploy/mfe-bundles" ]; then
             echo "Syncing mfe-bundles with delete..."
             find "deploy/mfe-bundles" -mindepth 1 -maxdepth 1 -type d | while read sub_dir; do
                relative_path="${sub_dir#deploy/}"
                aws s3 sync "$sub_dir" "s3://${S3_BUCKET}/$relative_path" \
                  --delete \
                  --cache-control "public,max-age=31536000,immutable" \
                  --exclude "*/remoteEntry.json"
             done
          fi

          # 2. Handle assets
          if [ -d "deploy/assets" ]; then
             # A. App-Specific Assets (e.g., assets/shell/) -> Strict Sync (Delete)
             # Keeps the specific folder clean of old files
             if [ -d "deploy/assets/${APP_NAME}" ]; then
                 echo "Syncing ${APP_NAME} specific assets (Strict)..."
                 aws s3 sync "deploy/assets/${APP_NAME}" "s3://${S3_BUCKET}/assets/${APP_NAME}" \
                  --delete \
                  --cache-control "public,max-age=31536000,immutable"
             fi

             # B. Shared/Design System Assets -> Additive Sync (No Delete)
             # Syncs fonts, icons, logo from node_modules that live in root assets/
             # Excludes the specific folder we just handled
             echo "Syncing shared design system assets (Additive)..."
             aws s3 sync "deploy/assets" "s3://${S3_BUCKET}/assets" \
              --exclude "${APP_NAME}/*" \
              --cache-control "public,max-age=31536000,immutable"
          fi

          # 3. Handle Root Files (Shell Bundles) - Copy Only
          # Avoid 'sync --delete' at root to prevent wiping other MFEs
          # Copy all root files (e.g. favicon.ico) excluding explicit no-cache files.
          find deploy -maxdepth 1 -type f | while read file; do
             fname=$(basename "$file")
             
             # Skip sensitive files that are handled later
             if [[ "$fname" == "index.html" || "$fname" == "remoteEntry.json" ]]; then
                 continue
             fi
             
             # Determine Cache Control based on filename
             # Mutable: favicon.ico, robots.txt, sitemap.xml, manifest.json
             # Immutable: Everything else (hashed bundles)
             CACHE_CONTROL="public,max-age=31536000,immutable"
             
             if [[ "$fname" == "favicon.ico" || "$fname" == "robots.txt" || "$fname" == "sitemap.xml" || "$fname" == "manifest.webmanifest" || "$fname" == "manifest.json" ]]; then
                 CACHE_CONTROL="no-cache,no-store,must-revalidate"
             fi

             echo "Copying root file: $fname (Cache: $CACHE_CONTROL)"
             aws s3 cp "$file" "s3://${S3_BUCKET}/$fname" --cache-control "$CACHE_CONTROL"
          done

          # 4. Deploy index.html (No Cache)
          if [ -f "deploy/index.html" ]; then
            aws s3 cp deploy/index.html s3://${S3_BUCKET}/index.html \
              --cache-control "no-cache,no-store,must-revalidate"
          fi
          
          # 5. Deploy config (No Cache)
          # Note: Runtime config already deployed in previous step for shell-mfe
          # This handles any config/ folder in the artifact itself
          if [ -d "deploy/config" ]; then
            aws s3 sync deploy/config/ s3://${S3_BUCKET}/config/ \
              --cache-control "no-cache,no-store,must-revalidate"
          fi
          
          # 6. Update remoteEntry.json (No Cache) - Universal
          find deploy -name "remoteEntry.json" | while read file; do
            s3_path="${file#deploy/}"
            aws s3 cp "$file" "s3://${S3_BUCKET}/${s3_path}" \
              --cache-control "no-cache,no-store,must-revalidate"
          done
          
          echo "âœ… Deployed to S3"
          echo "ðŸ“ Runtime config available at: /config/config.json"
      
      - name: Invalidate CloudFront
        env:
          DISTRIBUTION_ID: ${{ secrets.CLOUDFRONT_DISTRIBUTION_ID }}
          APP_NAME: ${{ steps.vars.outputs.app_name }}
        run: |
          echo "ðŸ”„ Invalidating CloudFront..."
          
          # Avoid "Cache Dumping" anti-pattern by invalidating only what changed
          if [ "$APP_NAME" == "shell" ]; then
             PATHS="/index.html /remoteEntry.json /config/config.json /favicon.ico /robots.txt /manifest.json /assets/shell/*"
          else
             PATHS="/mfe-bundles/${APP_NAME}/remoteEntry.json /assets/${APP_NAME}/*"
          fi
          
          aws cloudfront create-invalidation \
            --distribution-id ${DISTRIBUTION_ID} \
            --paths $PATHS
      
      # ========================================================================
      # Validate Deployment
      # ========================================================================
      - name: Smoke test
        env:
          CLOUDFRONT_URL: ${{ secrets.CLOUDFRONT_URL }}
        run: |
          echo "ðŸ§ª Running smoke test..."
          
          # Wait for CloudFront to propagate
          sleep 10
          
          # Test HTTP 200
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" ${CLOUDFRONT_URL})
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "âŒ Smoke test failed: HTTP ${HTTP_STATUS}"
            exit 1
          fi
          
          echo "âœ… Smoke test passed"
      
      # ========================================================================
      # Summary
      # ========================================================================
      - name: Deployment summary
        if: always()
        env:
          APP_NAME: ${{ steps.vars.outputs.app_name }}
          BUILD_VERSION: ${{ steps.vars.outputs.build_version }}
          ENVIRONMENT: ${{ steps.vars.outputs.environment }}
          SOURCE: ${{ steps.vars.outputs.source }}
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            STATUS="âœ… SUCCESS"
          else
            STATUS="âŒ FAILED"
          fi
          
          echo "### ${STATUS} - Deployment to ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Application:** ${APP_NAME}" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${BUILD_VERSION}" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${ENVIRONMENT}" >> $GITHUB_STEP_SUMMARY
          echo "**Source:** ${SOURCE}" >> $GITHUB_STEP_SUMMARY
          echo "**CloudFront:** ${{ secrets.CLOUDFRONT_URL }}" >> $GITHUB_STEP_SUMMARY
